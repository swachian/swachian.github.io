<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: 技术 | Hegel2011的博客]]></title>
  <link href="https://swachian.github.io//blog/categories/技术/atom.xml" rel="self"/>
  <link href="https://swachian.github.io//"/>
  <updated>2025-07-02T15:42:11+08:00</updated>
  <id>https://swachian.github.io//</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C# and .Net Notes]]></title>
    <link href="https://swachian.github.io//blog/2025/07/01/csharp/"/>
    <updated>2025-07-01T17:08:00+08:00</updated>
    <id>https://swachian.github.io//blog/2025/07/01/csharp</id>
    <content type="html"><![CDATA[<p>括号的单词：<br/>
parentheses (), round brackets<br/>
braces {}, curl ~<br/>
brackets [], square brackets<br/>
angle brackets &lt;><br/>
villainous org 反派组织</p>

<p><ItemGroup> 和global using可以关联</p>

<p><code>@"c:\t"</code> 加入<code>@</code>可以防止转义，从而达到verbatim（一字不差）<br/>
<code>$"{value}"</code> 外面一个<code>$</code>表示里面一层<code>{}</code>用于计算，如果两个<code>$$</code>，则里面要两层<code></code>才运算，这叫Raw interpolated string<br/>
Raw string literals, C#引入了三个引号<code>"""</code> ，其实引号可以更多，如果你被引的文字里需要直接写更多的引号<br/>
<code>default(string) ?? "&lt;NULL&gt;"</code> 中间的两个<code>??</code>表示if null then right<br/>
<code>WriteLine(format: "{0,-10} {1,6:N0}",arg0: applesText, arg1: applesCount);</code>, 里面的0和1是表示参数的index，逗号后面是表示alignment对齐的位数，colon后面是表示按数字还currency来处理</p>

<p>Null-coalescing operations
<code>string? author</code><br/>
<code>author?.Length ?? 30;</code><br/>
<code>author ??: "unknown"</code></p>

<p>Pattern Matching</p>

<p>当o为int时，直接赋值给i，后面即可把i作为int类型直接操作<br/>
<code>c#
if (o is int i)
{
  WriteLine($"{i} x {j} = {i * j}");
}
</code></p>

<p>c#7之后，patten也能用于switch<br/>
<code>c#
switch (animal)
  {
    case Cat fourLeggedCat when fourLeggedCat.Legs == 4:
      message = $"The cat named {fourLeggedCat.Name} has four legs.";
      break;
    case Cat wildCat when wildCat.IsDomestic == false:
      message = $"The non-domestic cat is named {wildCat.Name}.";
      break;
    case Cat cat:
      message = $"The cat is named {cat.Name}.";
      break;
    default: // default is always evaluated last.
      message = $"{animal.Name} is a {animal.GetType().Name}.";
      break;
    case Spider spider when spider.IsPoisonous:
      message = $"The {spider.Name} spider is poisonous. Run!";
      break;
    case null:
      message = "The animal is null.";
      break;
  }
</code></p>

<p>如果引入lambda， switch后的case也能当成expression<br/>
<code>c#
 message = animal switch
  {
    Cat fourLeggedCat when fourLeggedCat.Legs == 4
      =&gt; $"The cat named {fourLeggedCat.Name} has four legs.",
    Cat wildCat when wildCat.IsDomestic == false
      =&gt; $"The non-domestic cat is named {wildCat.Name}.",
    Cat cat
      =&gt; $"The cat is named {cat.Name}.",
    Spider spider when spider.IsPoisonous
      =&gt; $"The {spider.Name} spider is poisonous. Run!",
    null
      =&gt; "The animal is null.",
    _
      =&gt; $"{animal.Name} is a {animal.GetType().Name}."
  };
</code></p>

<p><code>int.TryParse()</code>, <code>int.Parse()</code>可以用于转换string到int</p>

<p>partial class可以实现对已有的class的开闭拓展</p>

<p>支持hash式入参，<code>TimesTable(number: 7, size: 10)</code></p>

<p>cardinal 基数，红衣主教<br/>
ordinal序列的</p>

<p>value switch<br/>
<code>c#
   string suffix = lastDigit switch
        {
          1 =&gt; "st",
          2 =&gt; "nd",
          3 =&gt; "rd",
          _ =&gt; "th"
        };
</code></p>

<p>contingent 代表团，exclusive to VS 专属于VS</p>

<p>csproj文件中可以引入另一个csproj，采用ProjectReference标签，更要一级的是sln（solution容器）</p>

<pre><code>  &lt;ItemGroup&gt;
    &lt;ProjectReference Include="..\CalculatorLib\CalculatorLib.csproj" /&gt;
  &lt;/ItemGroup&gt;
</code></pre>

<p>\ forward slash<br/>
/ backward slash</p>

<p>c# 支持out出的入参<br/>
<code>c#
if (int.TryParse(input, out int count))
{
  WriteLine($"There are {count} eggs.");
}
</code></p>

<h2>进入OO</h2>

<p>alias： <code>using ENV = System.Environment</code></p>

<p>object initializer syntax, 很多样化的syntax</p>

<pre><code class="c#">Book book = new(isbn: "978-1803237800",
  title: "C# 12 and .NET 8 - Modern Cross-Platform Development Fundamentals")
{
  Author = "Mark J. Price",
  PageCount = 821
};
</code></pre>

<p><code>[Flags]</code>类似java的annotation，是一种decorating</p>

<p>使用<code>readonly</code>优先于<code>const</code>，c#中的const只能用于原始类型，且在编译时就已经确定了值。</p>

<p>大写的是Property，小写的是field，field是不对外暴露的</p>

<p>optional parameters，naming parameters必须出现在required params后面</p>

<p>in, out, ref,
<code>public void PassingParameters(int w, in int x, ref int y, out int z)</code>
ref和out的区别在于，out的参数由method实现初始化</p>

<p>tuple的返回以及naming<br/>
```c#
 // Method that returns a tuple: (string, int).
  public (string, int) GetFruit()
  {
    return ("Apples", 5);
  }
  (string, int) fruit = bob.GetFruit();
  (string fruitName, int fruitNumber) = bob.GetFruit();</p>

<pre><code>
local function，支持function内再建function  
</code></pre>

<p>// Method with a local function.
  public static int Factorial(int number)
  {
    if (number &lt; 0)
    {
      throw new ArgumentException(
        $"{nameof(number)} cannot be less than zero.");
    }
    return localFactorial(number);</p>

<pre><code>int localFactorial(int localNumber) // Local function.
{
  if (localNumber == 0) return 1;
  return localNumber * localFactorial(localNumber - 1);
}
</code></pre>

<p>  }
```</p>

<p>partial除了修饰method，还能修饰method，便于与自动生成的代码共存<br/>
```c#
// Auto-generated designer file
partial class FormDesigner
{
    partial void OnInitialized();</p>

<pre><code>public FormDesigner()
{
    InitializeComponent();
    OnInitialized(); // Optional hook
}
</code></pre>

<p>}</p>

<p>// Your custom code
partial class FormDesigner
{
    partial void OnInitialized()
    {
        // Add custom initialization code
    }
}
```</p>

<p>indexer其实就是按数组方式去访问<br/>
```c#
  #region Indexers: Properties that use array syntax to access them.</p>

<p>  public Person this[int index]
  {
    get
    {
      return Children[index]; // pass on to the List<T> indexer
    }
    set
    {
      Children[index] = value;
    }
  }
```</p>

<p>Pattern matching: 1. 类型模式 2. 关系模式( > &lt; =>) 3. 属性模式<br/>
```c#
var employee = new Employee { Name = "Charlie", IsManager = true };</p>

<p>string role = employee switch
{
    { IsManager: true, Name: var name } when name.StartsWith("C")
        => "Manager with a C-name",
    { IsManager: true } => "Just a manager",
    _ => "Regular employee"
};
```</p>

<p>属性的get，set以及init，init表示必须在构造函数函数中被初始化，注意属性名称使用的是大写<br/>
<code>c#
public class Book
{
  public string Title { get; set; }
  public string? Author { get; set; }
}
</code>
record的==比较是按value进行的，而其他reference按value实现比较的只有string<br/>
```c#
AnimalRecord ar1 = new() { Name = "Rex" };</p>

<p>// 定义primary constructor，Kotlin也是类似的做法
public Headset() : this("Microsoft", "HoloLens") { }
```</p>

<p>操作相同类的method： 即this是自己，而传入的参数比如this.method1(that)的that也是本class，最好同时提供静态方法和实例方法。<br/>
定义operator的重载，指<code>+-*/</code>的重载。</p>

<pre><code class="c#">// Define the + operator to "marry".
  public static bool operator +(Person p1, Person p2)
  {
    Marry(p1, p2);

    // Confirm they are both now married.
    return p1.Married &amp;&amp; p2.Married;
  }
</code></pre>

<p>Generic 例子<br/>
<code>c#
Dictionary&lt;int, string&gt; lookupIntString = new();
lookupIntString.Add(key: 1, value: "Alpha");
</code></p>

<p>delegate and EventHandler<br/>
```c#
  public event EventHandler? Shout; // null initially.</p>

<h1>region Defining and handling delegates</h1>

<p>// Assign the method(s) to the Shout event delegate.
harry.Shout += Harry_Shout;
harry.Shout += Harry_Shout_2;</p>

<p>// 触发时，就会把所有注册给Shout的handler都调用一遍
    if (Shout is not null)
    {
      // ...then call the delegate to "raise" the event.
      Shout(this, EventArgs.Empty);
    }
```</p>

<p>IComparable 和 IComparer<br/>
```c#
public class Person : IComparable<Person>
{
  public int CompareTo(Person? other)
  {
    int position;
    return position;
  }
}</p>

<p>Array.Sort(people);</p>

<p>public class PersonComparer : IComparer&lt;Person?>
{
  public int Compare(Person? x, Person? y)
  {
    return 0;
  }
}</p>

<p>Array.Sort(people, new PersonComparer());
<code>
多个接口定义的方法名相同时，可以使用显示实现的版本。在调用时必须指明接口    
</code>c#
interface IWriter { void Write(); }
interface IEncoder { void Write(); }</p>

<p>class Processor : IWriter, IEncoder
{
    void IWriter.Write() => Console.WriteLine("Writing to file.");
    void IEncoder.Write() => Console.WriteLine("Encoding data.");
}
// 调用
var processor = new Processor();
((IWriter)processor).Write(); // 输出: Writing to file.
((IEncoder)processor).Write(); // 输出: Encoding data.
// processor.Write(); // ❌ 编译错误：不能直接通过类实例调用
```</p>

<p>int? a 表明可能可能为空，还有GetValueOrDefault()可以返回默认值，int的默认值是0</p>

<p>inherit，用一个colon表示<br/>
<code>public class Employee: Person {}</code></p>

<p>只有标明多态的方法，才能在method前面用override，否则只能用new来hide父类的方法，且不会有多态的效果。指明多态，需要在父类层级中的某个地方定义该method为<code>virtual</code>.</p>

<p><code>this</code>和<code>base</code>是区分子类和父类的关键字</p>

<p>obj转类型时可以用if语句检查后避免使用cast</p>

<p>constructors不会被继承，除非使用base()调用<br/>
```c#
public class PersonException : Exception
{
  public PersonException() : base() { }</p>

<p>  public PersonException(string message) : base(message) { }</p>

<p>  public PersonException(string message, Exception innerException)
    : base(message, innerException) { }
}
```</p>

<p>extension methods:<br/>
利用static class和static method，加上(this string input) 就可以给string加上实例方法。实际上只是一个语法糖，这个东西也很自然地被kt抄了过去<br/>
```c#
public static class StringExtensions
{
  public static bool IsValidEmail(this string input)
  {
    // Use a simple regular expression to check
    // that the input string is a valid email.</p>

<pre><code>return Regex.IsMatch(input,
  @"[a-zA-Z0-9\.-_]+@[a-zA-Z0-9\.-_]+");
</code></pre>

<p>  }
}</p>

<pre><code>
自定义的class，初始化特性，继承性，==的计算，都是按内存来进行比对和操作的  
struct分配的变量存储在stack里，默认没有==方法，但record struct是有的。  

.net 虚拟机的一些概念  
IL - Intermediate Language  
CLR - Common Language Runtime  
BCL - Base Class Libraries  
Assembly -&gt; NuGet package(dlls)  
namespace - type的地址  
RootNamespace在assembly的cproj文件里定义了全局的地址  
PropertyGroup中定义控制build的属性  
ItemGroup中定义需要包含的东西  
一个dll(assembly)可以包含多个namespaces  
Package是用于管理依赖的，通常和dll一一对应  
nuget.config定义project，solution的配置，一层一个文件，overriding式的  
string和int这样小写的关键字，最后会关联到System里面的String和Int32这样的类  
可以在nuget.org上发布自己的dll，类似nexus  

`{Math.BigMul(number1, number2):N0}` 用于两个大数相乘  
Random.Shared 可以构造随机数字  

List(Add, Insert, Remove, RemoveAt)  
Dictionary(Add, Remove)  
HashSet(Add, Remove)  
Queue(Enqueue, Dequeue)  
Stack(Push, Pop)  
Sorted Collections(SortedDictionary, SortedList, SortedSet)  
BitArray, LinkedList&lt;T&gt;  

Readonly是只读的list，而ImmutableDictionary可以有Add操作，但结果是返回一个全新的dictionary.  
</code></pre>

<p>// Call the Add method with a return value.
ImmutableDictionary&lt;string, string> newDictionary =
  immutableKeywords.Add(
    key: Guid.NewGuid().ToString(),
    value: Guid.NewGuid().ToString());
```
还有concurrent的版本，有的搭配await/async使用<br/>
FrozenSet和FrozenDictionary则则没有Add和Remove方法<br/>
EnsureCapacity(10_000)可以给定size</p>

<p>Index：<br/>
s[^5]获取倒数第5个元素<br/>
<code>c#
Range r1 = new(start: 3, end: 7);
r3 = 3..7;
r7 = ..3; //从0到3
</code></p>

<p>c#的两个点<code>..</code>也是一种spread的操作法，这一点不同于JS的三个点<br/>
使用range可以返回某个连续集合的span，span默认情况下引用的是原collection内的元素地址，从而可以提高性能</p>

<p>使用<code>Path.DirectorySeparatorChar</code>来构造文件路径，<code>Path.Combine(current, "images")</code>组合路径<br/>
stream helper是一种decorator，如果gzip，CryptoStream等等<br/>
streamReader， StreamWriter，</p>

<p>EF建设在ADO.NET上，后者是类似JDBC的一套东西。<br/>
Fluent API<br/>
扩展自DbContext， OnConfiguring定义数据源等信息<br/>
OnModelCreating中定义关联关系<br/>
例子的代码给了用scaffold从表格中生成partial class的例子，但我聚的这种大量attributes（annotation）的写法入侵性太重，手法并不好。<br/>
configureConventions配置惯例，例如所有的string类型默认50的长度<br/>
IQueryable<Product>?.ToQueryString()<br/>
optionsBuilder.LogTo().EnableSensitiveDataLogging可以配置EF的日志，用于调试SQL<br/>
查询的时候能由tagwith输出日志。</p>

<p>Principal Entity -- contains primary key<br/>
Dependent Entity -- contains foreign keys<br/>
Required relationship -- contains foreign key and is non-nullable<br/>
Optional relationship -- contains foreign key and is nullable<br/>
HasOne/HasMany, WithOne/WithMany<br/>
HasForeignKey<Ticket>表示ticket里面会有这个对象的外键<br/>
HasPrincipalKey可以指定关联的主键<br/>
abstraction -- focus on a single concern<br/>
Lower and Higher order abstractions<br/>
encapsulation -- 封装的是状态<br/>
ORM eliminate the need for repositories<br/>
Avoid shallow abstractions<br/>
Cartesian explosion, 多个一对多的情况下返回数据过多<br/>
Navigation and AutoInclude() 主动加载<br/>
<em>context.Entry()分别载入<br/>
.AsSplitQuery()没有涉及LazyLoading<br/>
Add, Update, Attach， 倾向于使用显示的repository<br/>
</em>context的FromSqlInterpolated($@"{}")<br/>
dbContext已经使用了unit of work这种模式</p>

<p>IQueryable<Student> vs IEnumerable<Student><br/>
Run on DB               Run in Memory<br/>
use internally          queryable.As Enumerable()<br/>
Return the most specific type<br/>
更推荐IReadOnlyList返回，这个会直接执行。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript To TypeScript]]></title>
    <link href="https://swachian.github.io//blog/2025/06/15/javascript-to-typescript/"/>
    <updated>2025-06-15T17:33:00+08:00</updated>
    <id>https://swachian.github.io//blog/2025/06/15/javascript-to-typescript</id>
    <content type="html"><![CDATA[<p>JS的7个基本类型：undefined, null, boolean, number, symbol, string, bigInt<br/>
array, object, function都是可变的，也就是reference类型的<br/>
string的提取有slice, substring. slice和substring的功能基本一样，但slice支持复数，含义为从右边开始数<br/>
array也有slice，含义和string一样。array还有splice，这个可以用于删除数组中的元素, 且第二个参数表示删除的个数，而slice和substring输入的参数表示index</p>

<p>基本的运算符、大小关系比较符等<br/>
if, swich, while, do while, for 语句，这些和c一样，for ... in 语句是js也支持的</p>

<p>函数是顶级的，可以作为引用传来传去，而且在里面实现了<strong>闭包(closure)</strong>,由此实现了状态的记忆和curry（函数生成函数，high order)<br/>
js的函数是没有重载，call和apply可以对某个函数对象进行调用。第一个参数都是传入的this，也就是要执行的对象；优先使用call，尤其搭配新的<code>...</code>扩展符，<code>greet.call(person, ...args)</code>, apply是传入一个数组，也是在各类语言中常见的一个名字</p>

<p>Array 可以用字面量<code>[]</code>直接定义，也用<code>[i]</code>作为index来访问。知名方法有<code>join, split, slice, push/unshift, pop/shift, sort, reverse, splice</code>. <code>splice(0, 2)</code>表示删除0开始的2项，<code>splice(2, 1, "a", "b")</code>删除位置2的1项并插入<code>"a", "b"</code></p>

<p><code>this</code>指向调用的对象，如为空则在非严格模式下指向全局。lambda的写法（arrow function）没有默认的this。</p>

<p>传统上，js用Function的construct和prototype来模拟class和继承<br/>
ES6中引入了<code>...</code>spread, Destruction <code>{a, b, c} = obj // the obj has a b and c properties</code>, 提供了let和const<br/>
还有class extends， 引入symbol解决命名冲突最大使用场景是iterator。<br/>
Promise搭配then使用完成异步，await/async更加先进，但await只能用在async的函数中。Promise本质上是给出resolve和err两个方法体，await和async则需要自己写catch error。<br/>
Map，Set两个基础数据结构，还有不影响gc的WeakMap和WeakSet。<br/>
Proxy Handler实现了给对象及其方法加上proxy的设计模式，便于修改原先的方法而返回handler给客户使用<br/>
<code>export {}</code>, <code>import {x} from . //导入一个或多个变量</code>, <code>import x from . // 导入Default</code>， <code>import * as matchers from // 在ts中用的较多</code></p>

<h2>React</h2>

<p>新型的React在return时用()包裹的目的就是避免后面换行对内容的干扰，本质上就是返回一个字符串可以被react进一步解析里面的<code>{}</code>变量<br/>
返回的内容通常就是html，也包含了需要动态替换的内容和监听的事件处理函数</p>

<p>RFR(React Fast Fresh), HMF(Hot Module Replacement)实现了react开发中的热更新<br/>
JSX是一种流行的返回格式，在多种Framework中流行<br/>
eslint在8.3之后，配置文件位于eslint.config.js中</p>

<p>组件的Function是用Pascal风格书写（首字母大写的驼峰拼写），然后就能在html和其他组件中按<code>&lt;FunctionName&gt;</code>来引用了<br/>
要监听的事件，可以放在组件的Function里。如果加入单元测试的话，小的组件可能也要考虑export。<br/>
函数理论上传入的对象是<code>props</code>, 例如<code>const Search =&gt; (props) =&gt; {}</code>, 但实际上为了简化利用ES6的destruction特点，可以写作<code>const Search =&gt; ({currentValue, setCurrentValue, children}) =&gt; {}</code><br/>
<code>children</code>是一个内部的prop，可以起到类似vue中slot和{} 传给fun的作用。</p>

<p><code>useState</code>是React的use系列methods之一，本质是同时返回一个类似proxy的handler，这样当使用这个handler修改参数时，可以引起涉及该变量的JSX的修改，从而引发render  <br/>
并且这个handler可以作为属性传给其他组件<br/>
```js
const [currentValue, setCurrentValue] = useState(value)</p>

<p><Search currentValue={currentValue} setCurrentValue={setCurrentValue}>
        Search: &nbsp;&nbsp;
</Search>
<code>``
传入时，也就是</code>{...item}<code>用在右边的时候，会自动展开传给函数，甚至可以自动转成nested的。  
定义时，也就是</code>({ojbectId, ...item})`用在左边时，就把传入对象objectId之外的部分写入item，这个称之为rest。</p>

<p><code>useEffect</code>可以监测state的变化，并执行里面顶一顶操作。<br/>
```js
const [count, setCount] = useState(0);</p>

<p>  useEffect(() => {
    console.log(<code>count 变化为: ${count}</code>);
    document.title = <code>当前计数: ${count}</code>;</p>

<pre><code>// 清理函数（如取消未完成的请求）
return () =&gt; {
  console.log('清理上一次的 effect');
};
</code></pre>

<p>  }, [count]);
<code>  
如果不传入第二个参数，那么就是起到只执行一次的作用。  
</code>js
  useEffect(() => {</p>

<p>  }, []);
```</p>

<p>customer hooks指利用现有的两个use可以封装自己的customer hook库。<br/>
1. useFetch - 封装数据请求逻辑<br/>
2. useDarkMode - 管理暗黑模式状态<br/>
3. useDebounce - 实现防抖功能<br/>
4. useWindowSize - 监听窗口尺寸变化</p>

<p>Reducer就是函数式编程里面的reducer，<code>(state, newValue(or action)) : new_state =&gt; {}</code><br/>
然后把它和初始state传给useReducer，就像useState一样可以得到一个初始状态的变量和handler，随后每次给这个handler传入一个新的value（或者理解成action）<br/>
<code>``js
const stateReducer = (state, action) =&gt; {
    switch (action.type) {
        case 'read':
            ...
            break
        case 'refresh':
            ...
            break
        default:
            throw new error(</code>Unsupported action type '${action.type}'`)
    }
}</p>

<p>const [state, setState] = useReducer(stateReducer, [])</p>

<p>setState({type: 'read', payload: {}})
```
这里面的state也可以是一个含有多个参数的对象，从而可以把整个组件的操作封装起来。</p>

<p>现代浏览器自带了<code>fetch</code>的异步调用函数，实际上用ajax库更多一些，fetch先返回response，然后再异步读取json<br/>
<code>js
    const response = await fetch(`${API_ENDPOINT}${param}`)
    const json = await response.json()
</code></p>

<p>useCallback把对函数的依赖转换成了对传入的第二个变量的依赖。因为在渲染组件时，Function会重新生成，所以导致引用handleClick的组件都会被重新渲染。使用useCallbak后，就把依赖转化为了传入的数组<code>[]</code>，就不会触发渲染了。搭配memo使用，效果更佳，但这会增加代码的复杂度。<br/>
```js
  const handleClick = useCallback(() => {
    setCount(c => c + 1)
  }, [])</p>

<p>  return (
    <div>
      <p>Count: {count}</p>
      <Button onClick={handleClick} />
      <button onClick={() => setOther(o => o + 1)}>Trigger Re-render</button>
    </div>
  )
```</p>

<p>import第三方内容，比如<code>import axios from 'axios'</code></p>

<p>async / await 在React中的用法没有太大不同，在useEffect里面使用时，需要注意要么把useEffect的lambda变成async，要么在这个lambda里面构造async的Function后，调用await才能生效。</p>

<p>css in React<br/>
```css
/<em> App.module.css </em>/
.container {
  background-color: #f0f0f0;
  padding: 20px;
}</p>

<p>.title {
  color: blue;
}
<code>
使用时
</code>js
// App.tsx
import React from 'react'
import styles from './App.module.css'</p>

<p>export default function App() {
  return (
    <div className={styles.container}>
      <h1 className={styles.title}>Hello, CSS Modules</h1>
    </div>
  )
}
```</p>

<p>vite-plugin-svgr的变化,诀窍在于问号后面跟react，表明这是一个可以用于react的svg图片的组件<br/>
```js
import Check from "./assets/check.svg?react";</p>

<p><Check height="18px" width="18px" />
```</p>

<p>React.memo与React.useMemo<br/>
useMemo和use系列一样，用第二个参数来控制要不要重新计算，主要针对组件中的method。<br/>
memo主要根据组件的入参来判断要不要重新渲染，主要用于父组件更新而子组件不需要更新的情况。</p>

<pre><code class="js">useMemo(() =&gt; {compute}, [a, b])

const Search = memo(({a, b, c}) =&gt; {
    return (
        "&lt;div&gt;content&lt;/div&gt;"
    )
})
</code></pre>

<h2>Learn TypeScript</h2>

<p>Learn TypeScript - Full Course for Beginners，done 6小时，基本学会了TypeScript，然后发现她也是C#的设计师设计的, 所以c#的语法很多。
应该TS优先。最早学习js就感觉没有一个架子（blue print)很麻烦，最近终于适应了js的灵活，却发现业界又把TS捧为最佳实践。尽管一开始就应该这样，但世界是个草台班子，实际的发展路线就是这样曲折。<br/>
运行ts或者tsx的可以是<code>ts-node -emx ...ts</code><br/>
ts要给每个参数都定义好type，用的语法比较简单，比如我有一个入参</p>

<pre><code class="js">{
  title: 'Redux',
  url: 'https://redux.js.org/',
  author: 'Dan Abramov, Andrew Clark',
  num_comments: 2,
  points: 5,
  objectID: 1,
},

// 我需要定义下面的type

type Story = {
    title: string,
    url: string,
    author: string,
    num_comments: number,
    points: number
    objectID: number
}

// 使用时
const List = (stories : Story[]) =&gt; {

}

// 传入的对象中有Function时，比如List也要传一个function，那么先定义ListProps
type ListProps = {
    stories: Story[],
    removeFunc: (item: Story) =&gt; void
}

// 前面reducer的例子可以传入一个action, 但每个type的payload属性不同，此时c#的pattern matching 登场了,在这里叫做Union Type

type Action = {type: 'read'; payload: Story[]}
| {type: 'refresh', payload: String}
// 注意，{}内部的分隔逗号和分号均可以


//调用useState时，也能给入参
const [currentValue, setCurrentValue] = useState&lt;string&gt;('')

// reducer可以这样写
const storiesReducer = (stories: Story[] , action: Action) =&gt; {
    switch (action.type) {
      case 'SET_STORIES':
        return action.payload
      case 'DELETE_STORY':
        return stories.filter(s =&gt; s != action.payload)
      case 'FILTER_STORY':
        return stories.filter(s =&gt; s.title.includes(action.payload))
      default:
        throw new Error(`Invalid action ${action}`)
    }
  }

// 传入一个复杂的react函数的type
type SearchProps = {
  currentValue: string, 
  setCurrentValue: React.Dispatch&lt;React.SetStateAction&lt;string&gt;&gt;, 
  children: ReactNode;
}

// 可以为空以及状态枚举的写法
type Order = {
    id: number
    pizza: Pizza
    sender?: string
    status: "ordered" | "completed"
}

// 定义泛型的写法，&lt;T&gt;是必须的，是通过这个来表示定义了一个泛型
function addToArray&lt;T&gt;(array: T[], item: T): T[] {
    array.push(item)
    return array
}

function getLastItem&lt;T&gt;(array: T[]): T | undefined {
    return array[array.length - 1] 
}

// Partial和Omit，以及可能返回为undefined，Omit表示传入了的类型不包含的属性，提醒后面需要增加，
// 和c#不同，ts这里的关键字也都是Pascal式的写法，而c#是全小写
function addNewPizza(pizza: Omit&lt;Pizza, "id"&gt;): Pizza | undefined{
    menu.push({
        id: nextPizzaId++,
        ...pizza
    })
    return menu[menu.length - 1]
}

// Partial把所有属性变为可选
type PartialUser = Partial&lt;User&gt;;
/* 等价于：
type PartialUser = {
  id?: number;
  name?: string;
  age?: number;
  email?: string;
};
*/
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从并发到Kotlin和模式的学习]]></title>
    <link href="https://swachian.github.io//blog/2025/04/30/cong-bing-fa-dao-kotlinhe-mo-shi-de-xue-xi/"/>
    <updated>2025-04-30T23:42:00+08:00</updated>
    <id>https://swachian.github.io//blog/2025/04/30/cong-bing-fa-dao-kotlinhe-mo-shi-de-xue-xi</id>
    <content type="html"><![CDATA[<p>在深入学习JVM并发艺术的过程中，了解到Kotlin的协程拥有比JAVA 21的协程更加的性能，从而对了解Kotlin实际情况产生了兴趣。同时，又找到了一本基于Kotlin的，讲解Gof模式实践和并发模式实践的书籍，于是跟着整本书，把Kotlin也学习了一遍。本文会就Kotlin的特点，相对于Java本身的优势和劣势做一些评价，也会对Kotlin高度配套的Arrow、Ktor、Vert.x写一些体会，同时，因为Kotlin明显受到了Scala的启发，所以也会谈一点关于scala的内容。</p>

<p>前4章讲了Kotlin的基础以及Gof的3类合计23个经典设计模式。Kotlin的语言风格和Java以及JS类似，实质上更像JS，因为她把函数作为一等公民，但很多语法又更像Java。</p>

<p>回忆要点：</p>

<h3>语法巡礼</h3>

<ul>
<li>打印语句是什么</li>
<li>简化的main方法</li>
<li>简化的分号semicolons</li>
<li>val var的类型声明以及类型推断</li>
<li>==和===的比较</li>
<li><p>Null safety</p></li>
<li><p>Lists, Sets, Maps的构造方式类似java，但有更明确的Mutable标识</p></li>
<li>数组，从list到数组以及arrayOf</li>
<li>if 和when控制语句</li>
<li>String里变量的解析 ${}</li>
<li><p>loop的写法</p></li>
<li><p>class和继承，用<code>:</code> 来表明继承</p></li>
<li>Properties及其method</li>
<li>必要时可给Property定制set get</li>
<li>interface和override</li>
<li>abstract class</li>
<li>只有open的class可以被继承，但通过编译糖实现了直接给现有类open一个method(Extension functions)</li>
<li>Data 类，也就是value object</li>
</ul>


<h3>创建有关的模式</h3>

<ul>
<li>单例 object关键字</li>
<li>Factory Method 是要抽象出被建对象的公共Interface</li>
<li>Abstract Factory 可以理解成是Factory Method的集成</li>
<li>Builder 目前很常用的方法，Kotlin里面增加了通过apply实现的Fluent setters，Default arguments等</li>
<li>Prototype Kt里面这就是一个copy</li>
</ul>


<h3>结构有关的模式</h3>

<ul>
<li>Bridge 引入中间对象类实现行为的委托，让原对象行为的变化通过变换bridge的对象来实现</li>
<li>Proxy 和Decorator一样，都包含一个传入的组合对象，只是更多的是做访问控制等工作，并且很可能执行路径和传入的参数很不一样</li>
<li>Decorator  <code>by repository</code>的意思是继承这个接口的时候使用输入的参数的实现类</li>
<li>Composite 把可能单个或者多个的同类参数组织起来，核心结构是包含一个集合，<code>varargs</code>关键字可以把输入的多个参数作为数组</li>
<li>Facade 把复杂的操作封装起来，这里举的例子有点像后面的中间人</li>
<li>Adapter asStream，asArray都是一种adapter的现实应用</li>
<li>Flayweight 通过缓存+单例实现内存使用减小</li>
</ul>


<h3>行为相关的模式</h3>

<p>责命解迭中记观，策状模访</p>

<p>Java的惯例是都是对象，所以所有的行为模式和结构模式都长的差不多。但是，对应Function优先的语言而言，Function不像对象那样是有状态的，所以可以实现纯策略模式。</p>

<ul>
<li>Chain of Responsibility 常见的filter其实就是一种责任链模式，通过提取一个公共的handler(比如request in response 出)函数为入参，就可以把这串方法串行调用起来</li>
<li>Command 把要执行的东西压入一个数组，然后提取出来分别执行，其实事件模型有点类似command，但command甚至可以执行回滚</li>
<li>Interpreter 解析复杂的文本为对象</li>
<li>Iterator  支持迭代模式的对象，就拥有了很多种和迭代器相关的能力，从遍历到map，reduce</li>
<li>Mediator 按他的说法，controller在MVC里就是一个中间人</li>
<li>Memento  顺便记录点东西</li>
<li>Observer launch等的核心模式</li>
<li>Strategy 这个其实是被使用的最多的一种模式，动态更换行为</li>
<li>State 通过状态不同来更新成员的状态对象，从而有不同的策略</li>
<li>Template Method 直接传入定制化的method，从而利用整个模板走完流程</li>
<li>Visitor 这个模式的核心其实是把不同元素的处理情况放到一个类中，用when或者switch进行集中处理，而这个类就叫visitor。她可以处理集合，处理集合时意味着丢给集合的accept后续处理，如遇到叶子结点，则直接对元素进行访问后获取自己需要的东西。</li>
</ul>


<p>随后本书进入了第二部分，关注于有反应(Reactive)和并发的Pattern。主要就是涉及FP（函数式编程）的模式，以及协程(Coroutines)、Channel、Flow等用于并发的组件。后者更像是基础框架对编程的影响，也由基础组件决定了程序编写的基本套路，即模式。<br/>
以协程为例，Java是17以后才引入的概念，之前只有线程。而Kotlin因为要为安卓服务，所以很早</p>

<h3>FP</h3>

<p>多核的兴起以及FP在意图性编程方面的优势，让FP翻红起来。</p>

<ul>
<li>function的几种写法，从最严格的到最简化的</li>
</ul>


<pre><code>fun generateMultiply1(): (Int, Int) -&gt; Int {
    return fun(x: Int, y: Int): Int {
       return x * y 
    }
}

fun generateMultiply2(): (Int, Int) -&gt; Int {
    return { x: Int, y: Int -&gt;
        x* y 
    }
}

fun generateMultiply3() = {x : Int, y : Int -&gt;
    x + y
    y + 3
}

fun subtract(x: Int) = fun(y: Int): Int {
    return x - y
}
</code></pre>

<ul>
<li>Trailing lambda  又称 call suffix，类似ruby的模板方法在尾部输入函数</li>
<li>Higher-order functions，forEach里面有自动入参<code>it</code>，是item的缩写</li>
<li>Clousures 由此支持了currying和Memoization记忆数组，本质就是让函数也可以有<strong>状态</strong></li>
<li>fun或者lambda里更多地使用expressions而不是statements</li>
<li>tailrec用于性能优化递归函数，限制是只能是最后一句包含递归，本质上这是compiler技术提升的一种表现</li>
</ul>


<h3>线程和协程</h3>

<ul>
<li>昂贵的Thread，因为消耗更多的内存，有Thread Stack，还有CPU间的Context Switch</li>
<li><p>coroutines，kotlinx-coroutines-core提供了这种轻量级线程的实现，通过with+launch或者with+async的方式来实现<br/>
<code>
  with(GlobalScope) {
      launch {
          delay(100)
      }
  }
  // with 在kotlin里让{}里的this自动指向入参，上面例子中就是GlobalScope，这个思路有点类似于decorator模式中举例的by repository。launch只是一个普通的method，但需要一个scope才能跑起来launch代表的coroutine
</code></p></li>
<li><p>runBlocking和suspend<br/>
```
fun main() {
  runBlocking {
      val job: Deferred<UUID> = fastUuidAsync()
      println(job.await())
  }
}</p></li>
</ul>


<p>suspend fun main() {
    val job: Deferred<UUID> = fastUuidAsync()
    println(job.await())
}
```</p>

<ul>
<li>Dispatchers.Default和Dispatchers.IO等，协程实质依赖线程运行，dispatcher就是这些线程，可以作为入参提供给launch和async</li>
<li>Structured concurrency，coroutines套coroutines，父协程要等待子协程们完成才结束。子协程的异常会导致父协程终止，supervisorScope可以防止这个异常繁殖传递，coroutineScope方法也能做此限制</li>
</ul>


<h3>控制数据流</h3>

<p>FP+coroutines的设计原则：</p>

<ul>
<li>Responsive, Resilient(supple), Elastic, Message-driven</li>
<li>collections上的高阶函数，reduce的话有一个fold和reduce类似，但可以提供initial value，flatMap和flatten，后者更简洁一点，类似toList()不用输入lambda</li>
<li>sequences 同list最大的区别在于不像list被整个处理，而是会被一个一个送出去并行处理，一般而言效率优于List</li>
<li>Channels kotlin版本的BlockingQueue，用于底层通信，属于热队列，既已经发出的消息不会重放, produce可以制造一个channel，搭配这个channel上的consumeEach</li>
<li>Actor，封装了channel和coroutine，但在kotlin中处于临期的状态</li>
<li>Flows，冷队列，会把消息从头到尾再发给新的监听者，用于数据流但实际上也能通过配置改变这种默认的行为，搭配为emit和collect，flow有点像tcp，有更高级的主题，例如shareIn，Conflate以及限流相关的debounce，sample，distinctUntilChanged等功能函数，spring的projectreactor也提供了类似的库，但没有协程助力，要采用事件驱动的写法</li>
</ul>


<h3>并发相关的设计模式</h3>

<ul>
<li>Deferred Value, java的Future，kotlin的Deferred，一般从async中返回</li>
<li>Barrier, kotlin中是用几个await等待几个异步的事情都完成后再进行处理，java中的CountDown，CylicleBarrier也都是干这种事情的</li>
<li>Scheduler，任务的调度（如何执行）和执行什么分离，再kotlin是Dispatcher，在java是executors</li>
<li>Pipeline, 把一个复杂的任务拆成流水，这样可以多个线程或协程同时运行小任务，也是stream设计的要点</li>
<li>Fan-Out, 把一个大任务分散后发出去，同Pipeline的区别在于可能只是批处理分发，而pipeline有更强的单个操作的协作性</li>
<li>Fan-In，Out后的东西最终往往需要汇总后才有意义</li>
<li>Racing，和Barrier类似，但只要有一个有效就可以忽略其他等待，kotlin在这里使用了select，即多路复用</li>
<li>Mutex，类似java最经典的synchronize，通过lock unlock来同步竞态资源</li>
<li>Sidekick，小外挂，把一部分工作包出去，目前AI计算和NVIDIA的关系就是N卡其实就是Sidekick</li>
</ul>


<p>至此，本书最精华的部分就讲解完毕了。后面又讲了3个常见的库和框架的使用，但更流于框架的使用说明，有些例子也举的不太好。
总体而言，本书的视角比较独特，用kotlin介绍的设计模式有令人耳目一新的地方。当然作者部分地方也显得功力不够，讲的不够清楚到位，有些例子也举的不是很好。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Kubernetes Book]]></title>
    <link href="https://swachian.github.io//blog/2021/10/26/the-kubernetes-book/"/>
    <updated>2021-10-26T09:47:00+08:00</updated>
    <id>https://swachian.github.io//blog/2021/10/26/the-kubernetes-book</id>
    <content type="html"><![CDATA[<p>The Kubernetes book, 购于Leanpub</p>

<h1>1&amp;2 Kubernetes 基础和操作</h1>

<h2>Control plane node (Masters, Heads)</h2>

<p>The API Server<br/>
   所有的入口</p>

<p>The cluster store(etcd)<br/>
    分布式数据库，3-5个拷贝，采用RAFT算法，由一个领袖说了算
    C优先于A，一旦不一致，就不能再更新了</p>

<p>The Controller manager<br/>
    Deployment, StatefulSet, ReplicaSet</p>

<p>The Scheduler<br/>
    检查Node的状况，给Node评分，以挑选合适的可以执行任务的Node</p>

<p>The cloud controller manager<br/>
    提供公有云服务的load-balancer到app的连接等</p>

<h2>Worker(Kubelet)</h2>

<p>Kubelet<br/>
    安装在主机上的代理，负责向heads汇报状态，并接受任务安排</p>

<p>Containerd<br/>
    从Docker抽象出来的接口，K8S已经不再直接支持Docker</p>

<p>kube-proxy<br/>
    运行在node上的网络组件，给每个node分配不同的docker内网，建立iptables表格完成路由功能</p>

<p>Kubernetes DNS<br/>
    每个Pod都有一个静态的Ip地址写了DNS服务，基于开源CoreDNS项目开发</p>

<h2>声明模式和渴望的状态</h2>

<ol>
<li>在manifest文件里声明目标状态（image，replicas数量，网络端口，如何更新）</li>
<li>Post给API服务（kubectl命令）</li>
<li>Kubernetes存入集群store（解析并分解成操作步骤入库）</li>
<li>Kubernetes实现目标状态(安排任务执行)</li>
<li>一个controller确保观察到的状态不会和目标状态不同(reconcile循环)</li>
</ol>


<h2>Pods</h2>

<p>A flock of birds 一群鸟 A pod of whales 一群鲸<br/>
所以pod就是一群dockers/containers</p>

<h2>Deployments</h2>

<p>一般不会直接部署pods，而是通过Controllers进行部署</p>

<h2>Service</h2>

<p>提供TCP UDP层面稳定的网络抽象</p>

<h1>3. 部署Kubernetes</h1>

<p>AWS: EKS, Azure: AKS, Google: GKE<br/>
腾讯: TKE, 阿里云: ACS（C是container）的缩写</p>

<p>可以在自己的机器上部署K8S作为练习：如docker Desktop，k3d, 开发可以用单机版的尝试</p>

<h2>kubectl</h2>

<p>~/.kube/config，中存放了命令行的操作配置</p>

<p>Clusters，Users和Contexts，前二者可以通过最后一个进行关联，表示用哪个用户的账号去操作哪个cluster</p>

<p><code>kubectl config current-context</code>用于查看当前活跃的context<br/>
<code>kubectl config use-context docker2</code> 用于调整当前活跃的context</p>

<h1>4. 用Pods工作</h1>

<ol>
<li>让资源共享：文件系统、同一个IP、共享内存、共享存储</li>
<li>一个pod中可以有多个containers，同一pod内的container可以通过localhost+不同的端口进行通信</li>
<li>通过Controller部署的pods才有高可用等特性支持</li>
<li>直接通过Pod manifest部署的pod，只有自生自灭</li>
</ol>


<p>Pod本身就是容器</p>

<h2>The pod network</h2>

<p>Pod的网络叫做pod network，是一种扁平的、各个pod可以彼此直接访问的组网。</p>

<h2>生命周期有长有短的pod</h2>

<p>long-lived: Deployments, StatefulSets, DaemonSets<br/>
short-lived: CronJobs, Jobs</p>

<p>长的多用于服务，短的多用于批量job。</p>

<h2>多Containers的几种花样</h2>

<p>Sidecar: 德国摩托车旁边的侧车；即一个container为主，一个为辅的模式。serice mesh里面常常用来对流量加密、暴露测量的数据<br/>
Adapter: sidecar的变种，比如把nginx的日志转变成普罗米修斯能解析的格式<br/>
Ambassador：也是变种，含义上讲更像是主container的使者<br/>
Init: 在拉起主app之前，执行一些辅助工作，通常只执行一次</p>

<p><code>kubectl apply -f pod.yml</code> 运行一个简单的pod，下面两个命令用于查询pod及其内容器的状态<br/>
<code>kubectl describe pods hello-pod</code><br/>
<code>kubectl get pods  hello-pod  -o wide</code></p>

<p>普通的执行命令 <code>kubectl exec hello-pod -- ps aux</code><br/>
获取pod内shell的命令 <code>kubectl exec -it hello-pod -- sh</code>, 注意需要加上<code>it</code></p>

<h1>5. Namespace</h1>

<p>查看命名空间 <code>kubectl get namespaces</code>  可以缩写为<code>ns</code></p>

<p>用kubectl可以命令式创建ns，用yaml文档可以声明式创建<br/>
<code>kubectl create ns hydra</code><br/>
<code>kubectl apply -f shields-ns.yml</code></p>

<p>切换默认的ns <code>kubectl config set-context --current --namespace ss</code></p>

<p>声明式的清除 <code>kubectl delete -f shield-app.yml</code></p>

<h1>6. Kubernetes部署</h1>

<p>Workload apis: Deployments, DaemonSets, StatefulSets</p>

<p>Deployments是aggregation root，内部其实还有ReplicaSet， 通过ReplicaSet来操作Pods</p>

<p>Reconcile：补锅，补偿，使得现实变成目标</p>

<pre><code class="yaml">piVersion: apps/v1
kind: Deployment
metadata:
  name: hello-deploy
spec:
  replicas: 10
  selector:
    matchLabels:
      app: hello-world
  minReadySeconds: 10
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
  template:
    metadata:
      labels:
        app: hello-world
    spec:
      containers:
      - name: hello-pod
        image: nigelpoulton/k8sbook:latest
        ports:
        - containerPort: 8080
</code></pre>

<p><code>.spec.selector</code>中的label选择了template中的app，注意label Selectors</p>

<p><code>ubectl get deploy hello-deploy</code><br/>
<code>kubectl scale deploy hello-deploy --replicas 5</code></p>

<p>rollback， clean-up</p>

<h1>7. Service</h1>

<ol>
<li>Service是一个K8S对象</li>
<li>Service有稳定的ip地址(a cluster ip)、dns名字以及port口</li>
<li>利用labels和selectors去动态地选择pods以传递流量</li>
</ol>


<p>从外部访问的方法：1. NodePort， 2. LoadBalancer</p>

<p>使用DNS服务作为服务发现的核心。Service名称会自动注册到DNS集群中，每个pod及其container都预先配置了dns集群的配置，以解决Service Name 到 ClusterIP之间的映射</p>

<h1>8. Ingress</h1>

<p>Ingress属于七层交换的概念，可以通过域名或路径等组合来转发请求</p>

<p>NodePorts的缺点： 使用的port偏大，30000-32767<br/>
LoadBalancer缺点： 需要和云的load-balancer 1-to-1 对应，开销容易很大<br/>
Ingress可以在只有一个云load-balancer的情况下完成多个服务的路由</p>

<p>不过，如果使用一个service mesh，可能Ingress的作用就不大了。</p>

<p>Ingress也是一种controller，只是大部分不是内建的。</p>

<p>可以使用helm创建nginx-ingress</p>

<pre><code>helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
helm repo update
helm install ingress-nginx ingress-nginx/ingress-nginx --namespace ss
kubectl get pods -n ss -o wide

ingress-nginx-controller-5c8d66c76d-2kq2f   1/1     Running   0          49m   10.244.2.34   master-node   &lt;none&gt;           &lt;none&gt;

kubectl get svc
NAME                                 TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)                      AGE
ingress-nginx-controller             LoadBalancer   10.108.112.4    &lt;pending&gt;     80:32003/TCP,443:30330/TCP   50m
</code></pre>

<p>但因为是自建的kubeadm，所以没有云原生的直接load-balance的支持，但可以通过32003端口对服务进行访问。</p>

<h1>9. 服务发现详解</h1>

<pre><code>kubectl get pods -n kube-system  -o wide
NAME                                           READY   STATUS    RESTARTS      AGE   IP             NODE                   NOMINATED NODE   READINESS GATES
coredns-78fcd69978-kb5td                       1/1     Running   1 (8d ago)    59d   10.244.0.4     office-wallet-dev-17   &lt;none&gt;           &lt;none&gt;
coredns-78fcd69978-l6m5g                       1/1     Running   1 (8d ago)    59d   10.244.0.5     office-wallet-dev-17   &lt;none&gt;           &lt;none&gt;
</code></pre>

<p>control plane上有dns集群</p>

<p>svc部署后会分配一个vip，也就是clusterIp；因为svc name最终会进入dns服务，所以这也是svc的命名规则要求和dns域名一致的根本原因</p>

<p>Kube-proxy会完成对Endpoints的监控和转发调整。现代版本的linux普遍使用IPVS，老的使用iptables。</p>

<p>clusterIp是一个不存在的IP，所以container传给node，node传给它的gateway（node的kernel，IPVS或Iptables），由kube-proxy负责对ClusterIp的重定向。
IPVS是L4 load-balancer，扩展的性能更优越。</p>

<p>服务发现和namespace</p>

<p><code>&lt;object-name&gt;.&lt;namespace&gt;.svc.cluster.local</code></p>

<p><code>kubectl get all -n dev</code> 可以同时列出 svc pods</p>

<h1>10. Storage</h1>

<p>Storage采用的CSI plugin的机制。</p>

<p>SC - StorageClass 定义存储的硬件<br/>
PVC - 变成PV的请求，也是Pod可以使用的存储  <br/>
PV - SC检测到PVC后，会变成PV</p>

<ul>
<li>PVC里的Access mode:

<ul>
<li>ReadWriteOnce(RWO)传统的一块硬盘</li>
<li>ReadWriteMany(RWM) NFS这种支持多个加载</li>
<li>ReadOnlyMany(ROM)  可被多少只读</li>
</ul>
</li>
</ul>


<p>PV只能按一种模式打开</p>

<p><code>kubectl get sc</code></p>

<p>解除后数据是否删除的策略：1. Delete 2. Retain<br/>
Sc中的VolumeBindingModo: 1. Immediate 2. WaitingForFirstConsumer(Pod)</p>

<pre><code class="yaml">apiVersion: v1
kind: Pod
metadata:
  name: volpod
spec:
  volumes:
  - name: data
    persistentVolumeClaim:
      claimName: pvc-prem
  containers:
  - name: ubuntu-ctr
    image: ubuntu:latest
    command:
    - /bin/bash
    - "-c"
    - "sleep 60m"
    volumeMounts:
    - mountPath: /data
      name: data
</code></pre>

<h1>11. ConfigMaps and Secrets</h1>

<p>ConfigMaps是键值对，value可以是一个简单的值，也可以是一整个配置文件。<br/>
注入container有几种方式：1. 环境变量 2. 启动的命令 3. volume中的文件<br/>
env var； cmd； vol</p>

<p><code>kubectl create configmap</code></p>

<p>vol最大的优势是一旦修改了configMap，可以在container的mount位置立刻看见修改。而两位两个必须重启容器。即Vol的注入是动态的，env的注入是静态的。</p>

<p>Secret只是以base64的形势存放起来</p>

<h1>12. StatefulSets</h1>

<p>与Deployment相比的差异：<br/>
1. 可预知的持久的pod名字<br/>
2. 可预知的持久的DNS主机名字<br/>
3. 可预知的持久度vol绑定</p>

<p>pod生成的规则：<StatefuleSetName>-<Integer>，而且是按顺序依次启动，完成前一个，才启动后一个。</p>

<p>Stateful controllers自己直接处理治愈和扩容，而不是假手ReplicaSet</p>

<h2>headless service and StatefulSet's governing service</h2>

<p>headless service就是clusterIP为空的service，搭配StatuefulSet，就会产生独立的每个pod的dns名称。app的调用也会基于具体的pod 名称。</p>

<p><code>volumeClaimTemplates</code>用于给每个stateful pod创建动态PVC。</p>

<p>独立pod的dns命名规则为<object-name>.<service-name>.<namespace>.svc.cluster.local</p>

<p>如果是pod退出，那么StatefulSet可以很容易地重新创建一个替代的pod。但如果是node不正常，则需要手工干预。</p>

<h1>13. API 安全和RBAC</h1>

<p>user,gourp, Service acct -> API server -> authN -> authZ -> Admission control</p>

<p>Kubernetes没有自己的identity database，主要通过和其他auth模块集成（plug-in）的方式来实现authN。<br/>
比如client certs，webhooks，IAM（Identity Access Management)</p>

<p>K8S的authZ只有allow没有deny，因为默认全部都是deny。</p>

<pre><code class="yaml">rules:
  - apiGroups: ["apps"]
    resources: ["deployments"]
    verbs: ["get", "watch", "list"]
</code></pre>

<p><code>*</code>意味着全部授权</p>

<p>4个RBAC对象</p>

<ul>
<li>Roles</li>
<li>ClusterRoles</li>
<li>RoleBindings</li>
<li>ClusterRoleBindings</li>
</ul>


<p>顾名思义，可以使用的namespace是不同的。需要注意的是，ClusterRoles经常和RoleBindings搭配使用。</p>

<p>Admission controller有很多个，实际主要负责批准相应的请求。</p>

<h1>14. The Kubernetes API</h1>

<p>JSON + Protobuf支持，</p>

<p>可以自己定义并扩展API</p>

<h1>15. Threat和K8S</h1>

<p>STRIDE 模型</p>

<p>Spoofing欺骗:<br/>
  - 通信层面的安全TLS<br/>
  - 限制pod和API server的通信，token的失效期等等</p>

<p>Tampering篡改:<br/>
  - 组件的篡改：etcd，api server，controller，scheduler，kubelet，镜像运行时，镜像文件等<br/>
  - 运行的pod修改</p>

<p>Repudiation否认:<br/>
  - 中央化的收集各个组件的审计日志</p>

<p>Information Disclosure 信息泄露:<br/>
  - KMS和HSM是实现key和数据在节点上分离</p>

<p>Denial of Service(DOS):<br/>
  - HA<br/>
  - WAF</p>

<p>Elevation of privilege:</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java 8 9 10 in action]]></title>
    <link href="https://swachian.github.io//blog/2021/10/04/java-8-9-10-in-action/"/>
    <updated>2021-10-04T21:22:00+08:00</updated>
    <id>https://swachian.github.io//blog/2021/10/04/java-8-9-10-in-action</id>
    <content type="html"><![CDATA[<h1>第一章</h1>

<p>第一作者写作时是剑桥的在读博士，同时第三作者是他的博士生导师。第二作者是Redhat的Java 8普及牛人。</p>

<p>Brian Goetz 把函数式编程内容加入Java，他也是java的架构师或者说设计师。</p>

<p>本书涉及了Stream, lambda, Optional, CompletableFuture, RxJava, Akka(Java 9)</p>

<p>Function变成一等公民，可以在运行时被传来传去。<br/>
method reference :: syntax<br/>
lambdas</p>

<p>原本<code>filter</code>等功能可以添加在Collections类中。但为了匹配多核时代，引入了streams，对并行(parallelStream)和单行stream进行了区分。</p>

<p><code>Default Method</code>的加入是为了让已经存在的List的实现类可以不需要自己单独去实现stream()这种方法，但这让java具备了多继承的能力。因为default method的加入，等于接口可以变成抽象类。</p>

<h1>第二章 行为参数化传递的方式</h1>

<p>lambda也是一个对象，也可以用工厂方法来构造</p>

<p>以前传行为（策略模式）是需要构造一系列的接口和类，实现共同的接口，因为只能传入对象。<br/>
Java匿名类：允许你声明和初始化一个类在同一时刻。<br/>
lambda和上面的特性一样，但更加精简</p>

<p>4个实际经常使用的匿名类接口：<code>Comparator</code>，<code>Runnable</code>，<code>Callable</code>，<code>EventHandler</code></p>

<h1>第三章 Lambda</h1>

<p>lambda可在Functional Interface(例如Predicate<T>）处被传入</p>

<p><strong>Functional Inteface就是有且只有一个抽象方法的接口。</strong><br/>
lambda就是一个Functional Interface的抽象方法的实现实例<br/>
<code>@FunctionalInterface</code> 对于Functional Interface的标注，表示有且仅有一个抽象接口。</p>

<p>FunctionalInterface就是lambda的引用类型，此时func也就变成了一个对象。<br/>
<code>java
Predicate&lt;T&gt; &lt;---&gt; T --&gt; boolean
Consumer&lt;T&gt; &lt;---&gt; T-&gt; void
Function&lt;T, R&gt; &lt;---&gt; T -&gt; R
Supplier&lt;T&gt; &lt;---&gt; () -&gt; T
Runnable &lt;---&gt; () -&gt; {}
</code></p>

<p>因为boxing的性能原因，上面还有一系列Int Long 之类的变种</p>

<h2>Target typing</h2>

<p>先根据被使用的FI类型，比如<code>filter</code>是<code>Predicate</code>，那么意味着需要一个输入为<code>T</code>返回为<code>boolean</code>的lambda。<br/>
同时，因为这个接口里面的method名字lambda并不会涉及，实际上叫什么也无所谓，所以要求FI只能有一个抽象method。这样的话，method具体叫什么就无所谓了，只要方法签名对的上，实现中甚至可以单独生成一个匿名类。</p>

<p>local variable 和instance variable在lambda中的异同，因为他们在JVM里面的位置不同，local var是在本地func的stack里，实例变量则在Heap中。所以local var必须加上final或者实际上只被赋值一次。</p>

<h2>3种Method Reference</h2>

<ol>
<li>静态方法 <code>Integer::parseInt</code></li>
<li>实例方法 <code>String::length</code></li>
<li>已存在对象的实例方法 <code>expensiveTransaction::insert</code></li>
</ol>


<p>上面的方法都可以传入多个参数，但同时也不需要使用()，毕竟只是声明需要使用这个method</p>

<p>构造方法作为一种特殊的method，也能成为method Reference</p>

<h2>FI中的其他接口（组合lambda表达式）</h2>

<p>适用组合模式，其他接口都是<code>default</code>类型的接口</p>

<p><code>Comparator: reversed, thenComparing</code><br/>
<code>Predicate: and, or, not</code>  <br/>
<code>Function: andThen, compose</code>, 注意二者的区别，前者是管道，后者是被compose的内容先执行</p>

<pre><code class="java">    Function&lt;Integer, Integer&gt; f = x -&gt; x + 1;
    Function&lt;Integer, Integer&gt; g = x -&gt; x * 2;
    Function&lt;Integer, Integer&gt; h = f.andThen(g);
    System.out.println("h(1): " + h.apply(1));
</code></pre>

<h1>第四章 Stream</h1>

<p><code>Collection</code>的弱点：1. 不能像SQL那样组合查询（declarative way 声明式查询） 2. 集合太大可能无法处理</p>

<p>民间自发的：<code>Guava</code>，<code>Apache</code>，<code>lambdaj</code>（本书第二作者的作品）</p>

<p><strong>Stream</strong>: Declarative, Composable, Parallelizable</p>

<p>Compute on demand, a lazily constructed collection</p>

<p>中间的操作：<code>filter</code>，<code>map</code>，<code>limit</code>， <code>sorted</code>，<code>distinct</code><br/>
Terminal操作：<code>collect</code>，<code>count</code>，<code>forEach</code></p>

<h1>第五章 Streams 2</h1>

<h2>操作</h2>

<p><strong>Filtering</strong>：<code>filter</code>, <code>distinct</code>, <code>takeWhile</code>(java 9), <code>dropWhile</code>(Java 9), <code>limit</code>, <code>skip</code><br/>
<strong>Mapping</strong>: <code>map</code>, <code>flatMap</code>(入参也是一个stream）<br/>
<strong>Finding</strong>：<code>anyMatch</code>，<code>allMatch</code>，<code>noneMatch</code>，<br/>
               <code>findAny</code>（返回的是Optional，后面接ifPresent），<code>findFirst</code>，<code>findAny</code>和<code>findFirst</code>的功能基本相同，区别在于并行的时候<code>findFirst</code>更加严格<br/>
<strong>Reducing</strong>（Terminal）：<code>reduce(0, Integer::sum)</code>, <code>reduce(Integer::sum</code>）但这个是返回<code>Optional</code>，因为可能stream里面没有元素<br/>
    <code>reduce</code>之前可map成其他数字或对象</p>

<p>Stateful和Stateless的操作，reduce是stateful的操作，但影响并不大。但是sorted，reverse，distinct就是需要空间很大的stateful操作了。</p>

<p>对于<code>IntStream</code>，需要使用boxed让其回到普通stream，或者使用mapToObj，而<code>rangeClose</code>可以构造一个整型int stream出来</p>

<h2>创建streams</h2>

<p><code>Stream.ofNullable(value)</code>，<code>File.lines</code>，<code>Arrays.stream(numbers)</code>，<code>Stream.iterate</code></p>

<h1>第六章 Collectiong 操作（Terminal的一种）</h1>

<p>返回一个值<br/>
返回一群元素<br/>
分区域的一群元素</p>

<pre><code class="java">count() &lt;---&gt; Collectors.counting()  
summingInt, summarizingInt,  
joining()
</code></pre>

<p><code>reducing</code>  --> Collector的reduce，更专业且支持并行操作，reducin接受<T>操作以及&lt;T, T,  T>两种函数接口</p>

<p><code>groupingBy</code>
的第二个参数可以继续传入groupingBy，实际上所有的collector都可以作为第二个参数传入。
默认的groupingBy其实是<code>groupingBy(f, toList())</code></p>

<p><code>collectingAndThen</code>也能传给groupingBy，在有些情况下可以去除里面返回的<code>Optional</code>，<code>maxBy(comparingInt(Dish::getCalories)), Optional::get)));</code>
<code>mapping</code>也经常搭配<code>groupingBy</code>使用，第一个参数是做转换，第二个参数是对转换后的元素做terminal操作。</p>

<p><code>partitioningBy</code>是一种特殊的，只有两个值（true or false）的<code>groupingBy</code></p>

<h2>Collector接口</h2>

<p>接口由4个function+1个特性枚举构成</p>

<p>Collector&lt;T, ?, List<T>> toList() {
        return new CollectorImpl&lt;>(ArrayList::new, List::add,
                                   (left, right) -> { left.addAll(right); return left; },
                                   CH_ID);
    }</p>

<p> static class CollectorImpl&lt;T, A, R> implements Collector&lt;T, A, R> {}</p>

<p>特性枚举：<br/>
1. UNORDERED<br/>
2. CONCURRENT<br/>
3. IDENTITY_FINISH</p>

<p>第2个必须在第1个的基础上才起作用，第三个表明finisher不需要做什么事情</p>

<p>Collector本身也提供了蓝图或者说框架，让开发更简单</p>

<h1>第七章 并行处理</h1>

<p>sequential 和 parallel，但只有最后一个被声明的生效</p>

<p>RecursiveTask<Long>，实现里面的compute() 方法, <code>new ForkJoinPool().invoke(task)</code></p>

<p><code>Spliterator</code>, 并行版的Iterator</p>

<h1>第八章 Collection API 加强</h1>

<p>Java 8:  <code>Arrays.asList</code><br/>
Java 9: <code>List.of</code></p>

<h1>第九章 重构、测试与调试</h1>

<p>lambda在很多情况下可以替换模板方法，以及相当一部分原先需要使用oo来实现的策略模式</p>

<p>多阶函数可以很好的完成职责链的工作，例如<code>thenCombine</code>，<code>thenComparing</code>，<code>and</code>，<code>or</code>等等</p>

<p><code>peek</code>可用于打印stream的内容，调试打印日志时比较有用</p>

<h1>第十章 DSL和lambdas</h1>

<p>用builder模式来实现复杂的构造！！！在builder中实现DSL。</p>

<h1>第十一章 Optional</h1>

<p><code>Optional</code>在定义domain的时候，明显表达了给属性可能为空的事实。<br/>
对于不会为空的字段，则不需要加上Optional。<br/>
用<code>map</code>可以得到里面的值，用<code>flatMap</code>可以脱去可能得到的返回也是<code>Optional</code>的情况</p>

<p>unwrapping的几个方法：<br/>
<code>get()</code>，不值得用，和null检查差不多。<br/>
<code>orElseGet()</code>， lazy 版本，最值得推荐<br/>
<code>orElseThrow()</code></p>

<p><code>map</code>, <code>flatMap</code>其实都是<code>Optional</code>也有的方法，默认返回会携带<code>Optional</code>，用于处理值为空的情况。</p>

<h1>第十二章 New Date and Time Api</h1>

<p>Java老的Date API的问题：<br/>
1. Date的命名不清，月份从0开始，年份从1900开始，没有什么时区的概念<br/>
2. 第二版出了Calendar，年份问题解决，但月份还是从0开始，两个并行带来了困扰<br/>
3. DateFormat不是线程安全的类<br/>
4. Calendar和Date都不是Value Object</p>

<p>新的API主要抄袭了Joda-Time的内容</p>

<p><code>LocalDate</code>，<code>LocalTime</code>，<code>LocalDateTime</code>由前两个组成，甚至localDate和localTime的实例中有<code>createLocalDateTime</code>的工厂方法  <br/>
<code>TemporaField</code>是接口，<code>ChronoField</code>是枚举的实现</p>

<p><code>Instant.now</code></p>

<p><code>Duration</code>用于表示纳秒/毫秒级别的差异，可以用<code>between</code>工厂方法创建<br/>
<code>Period</code> 用于表示天数之间的，可以用于<code>localDate</code>之间的差异<br/>
<code>TemporalAdjusters</code>的静态方法，提供了很多传给<code>with</code>方法以生成新日期对象的调节对象</p>

<p>可以选择实现自己的<code>TemporalAdjuster</code>接口或lambda<br/>
<code>java
 LocalDate date2 = date.with(nextWorkDay());
</code></p>

<p><code>LocalDate.parse</code>可以输入<code>DateTimeFormatter</code>，打印时直接<code>date.format()</code>里面输入需要的formatter</p>

<p><code>ZoneRules</code>，<code>ZoneId</code>，<code>ZoneId</code>混合<code>LocalDateTime</code>等可以新生成`ZonedDateTime</p>

<p><code>ZoneOffset</code>是ZoneId的子类</p>

<h1>第十三章 Default Methods</h1>

<p>为了兼容性，为了可以让API不断演进。</p>

<p>接口可以<code>extends</code>接口，实现多个默认default，会带来多继承的问题。<br/>
解决规则：<strong>Ambiguous的情况下会提示报错</strong>，要求用户再次选择。其他情况下：
1. class里实现的优先级总是高于Interface；
2. 子interface的优先级高于被继承的interface</p>

<p><code>X.super.m(..)</code>的新syntax用于解决Ambiguous的情况。</p>

<p>在子interface中定义一个抽象接口，那么实现该子interface的类就必须实现此方法，尽管在父interface里面可能存在default的实现。</p>

<h1>第十四章 Module</h1>

<p>Java的代码组织层级：1. class 2. package 3. jar，只有class拥有可见性的控制颗粒度，package和jar没有控制</p>

<p>多了require和export用于定义package的开放状态和依赖情况，这些信息位于<code>module-info.java</code>中</p>

<p>java运行时增加了参数 <code>--module-path</code> 可以在后面指定模块对应的jar包</p>

<h1>第十五章 并发（Concurrency）和并行（Parallelism）</h1>

<p>并发是事件类，就是一事未必，再起一事，然后等待几件事情同时得到结果。<br/>
并行是起多个任务同时交给多个core去做。<br/>
GC里也有类似的概念，并发GC意味着GC和应用程序同时进行，并行意味着应用程序暂停但开启多个线程做GC。</p>

<p><code>t1.join()</code>在主线程里面等待t1结束；<br/>
<code>Future&lt;Integer&gt; x</code>, <code>x.get()</code>会blocking等待线程运行结束</p>

<p>Java的新异步方案：<br/>
1. Java 8 中引入的<code>CompletableFuture</code>
2. Java 9 中引入的<code>Flow</code></p>

<p><code>CompletableFutur</code>e同时实现了组合接口，从而拥有了<code>thenCombil</code>e的能力。<code>executorService.submit</code>直接返回的就是<code>Future</code>，但使用<code>CompletableFuture</code>并不用再<code>submit</code>后取得返回，而是自己<code>new</code>了<code>CompletableFuture</code>后使用<code>get</code>。提交时也变成<code>executorService.submit(() -&gt; a.complete(f(x)))</code>;实际往往可以使用工厂方法创建。</p>

<p>订阅模式的pressure和<strong>backpressure</strong>，后者主要用于订阅者确保压力不会太大</p>

<h1>第十六章 CompletableFuture：可组合的异步编程</h1>

<p>主要是为了实现<code>future</code>的组合，其次也是因为Java 8提供了新的机制。Doug Lea大爷出品。</p>

<p><code>CompletableFuture.supplyAsync</code> 工厂方法，入参为Supplier接口，提供一个Callable的返回内容<br/>
所以一般不需要先new一个CompletableFuture再调用complete方法。<br/>
<code>CompletableFuture::join</code>方法可以等待多个join方法执行完成</p>

<pre><code class="java">N(threads) = N(CPU)*U(CPU)*(1+W/C), waitTime/computeTime
</code></pre>

<p><code>.thenApply</code>, <code>.thenCompose</code>，有些结尾如<code>thenComposeAsync</code>，意味着可以不在同一个线程里被执行.<br/>
<code>.thenCombine</code>则是互相不依赖的</p>

<p>Java 9 加入的timeOut特性：orTimeOut（报告异常），completeOnTimeout（添加默认的返回值）</p>

<p>第十七章 Reactive Programming</p>

<p><code>java.util.concurrent.Flow</code>，该接口被众多第三方库实现：<br/>
1. Akka（Lightbend）<br/>
2. Reactor(Pivotal)<br/>
3. RxJava(Netflix)<br/>
4. Vert.x(Red Hat)</p>

<pre><code class="java">public interface Publisher&lt;T&gt; {
    void subscribe(Subscriber&lt;? super T&gt; S);
}
</code></pre>

<pre><code class="java">public interface Subscriber&lt;T&gt; {
    void onSubscribe(Subscription s);
    void onNext(T t);
    void onError(Throwable t);
    void onComplete();  
} 
</code></pre>

<p>onSubscribe onNext* (onError | onComplete)?</p>

<pre><code class="java">public interface Subscription {
    void request(long n);
    void cancel();
}
</code></pre>

<pre><code class="java">public interface Processor&lt;T, R&gt; extends Subscriber&lt;T&gt;, Publisher&lt;R&gt; {}
</code></pre>

<h1>第十八章 函数式考虑</h1>

<p>Tail-recursive的递归可以优化性能，不过java不支持。这种方法的特点是函数的最后就是自己调用自己。</p>

<h1>第十九章 FP技巧</h1>

<p>Higher-order functions：传递函数作为参数的函数<br/>
Curring：可以分批应用参数的函数，其实就是把值先保存在函数体中<br/>
数据结构存储：每次新建一个（批）对象</p>
]]></content>
  </entry>
  
</feed>
